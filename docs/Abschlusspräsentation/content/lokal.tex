%!TEX root = ../vortrag.tex
\section{Lokale Variablen}
\begin{frame}[t,fragile]{Motivation}
	\begin{itemize}
		\item Einsparung doppelter Berechnungen: $f(x,y) = (1+x)^2 + (1-y)^2 + (1+x)(1-y)x$
	\end{itemize} 

	\begin{minted}{scheme}
		(define (f x y)
			(+ (square (+ 1 x))
			   (square (- 1 y))
			   (* (+ 1 x) (- 1 y) x)))
	\end{minted} 
	
	\begin{itemize}
		\item<2-> \bet{Idee:} Setze $a := 1+x$ und $b := 1-y$ und lagere Berechnung in eine anonyme Prozedur aus.
		\[
			f(x,y) = g(1+x,1-y) \text{ mit } g(a,b) = a^2 + b^2 + abx
		\]
		
		\only<3|handout:0>{\inputminted[lastline=2]{scheme}{code/motivation-lokal.scm}}
	
		\only<4->{\inputminted[firstline=4,lastline=7]{scheme}{code/motivation-lokal.scm}}

	\end{itemize}
\end{frame}

\begin{frame}[t,fragile]{}
	\[
		f(x,y) = g(1+x,1-y) \text{ mit } g(a,b) = a^2 + b^2 + abx
	\]
	\inputminted[firstline=4,lastline=7]{scheme}{code/motivation-lokal.scm}
	
	\bet{Auswertung von $f(3,2) = 5$:}
	
	\mintinline{scheme}{(f 3 2)}\\[0.25cm]
	\onslide<2->{$\rightarrow$ \mintinline{scheme}{((lambda (a b) (+ (square a) (square b) (* a b 3))) (+ 1 3) (- 1 2))}\\[0.25cm]}
	\onslide<3->{$\rightarrow$ \mintinline{scheme}{(+ (square 4) (square -1) (* 4 -1 3))}\\[0.25cm]}
	\onslide<4->{$\rightarrow$ \mintinline{scheme}{(+ (* 4 4) (* -1 -1) -12)}\\[0.25cm]}
	\onslide<5->{$\rightarrow$ \mintinline{scheme}{(+ 16 1 -12)}\\[0.25cm]}
	\onslide<6->{$\rightarrow$ \mintinline{scheme}{5}}
\end{frame}

\begin{frame}[t,fragile]{\texttt{let}}
	\mintinline{scheme}{let} als \textit{syntaktischer Zucker} für die eben gesehene \mintinline{scheme}{lambda}-Konstruktion: \ccite{sicp}{S. 65}
	
	\vspace*{0.5cm}

	\begin{minipage}{0.47\textwidth}
	\begin{center}
		\texttt{((lambda (\fslot{Name_1} \fslot{Name_2} \dots) \fslot{Rumpf}) \fslot{exp_1} \fslot{exp_2} \dots)}
	\end{center}
	
	\inputminted[firstline=10,lastline=12]{scheme}{code/motivation-lokal.scm}	
	\end{minipage}~\pause\hspace*{0.5cm}~
	\begin{minipage}{0.47\textwidth}
	\begin{center}
		\texttt{(let ((\fslot{Name_1}~\fslot{exp_1}) (\fslot{Name_2}~\fslot{exp_2}) \dots) \fslot{Rumpf})}
	\end{center}
	
	\inputminted[firstline=14,lastline=16]{scheme}{code/motivation-lokal.scm}	
	\end{minipage}
	
	\vspace*{0.5cm}
	
	\begin{itemize}
		\item<3->[$\Rightarrow$] Möglichkeit, \bet{lokale Variablen} zu definieren.
	\end{itemize}
	
	\onslide<3->{\inputminted[firstline=19,lastline=21]{scheme}{code/motivation-lokal.scm}}
\end{frame}

%\begin{frame}[t,fragile]{Ein kleiner Wermutstropfen\dots}
%	\begin{itemize}
%		\item Ersetze Namen der lokalen Variable \texttt{a} durch \texttt{y}.
%	\end{itemize}
%	
%	\only<2>{\inputminted[firstline=23,lastline=26]{scheme}{code/motivation-lokal.scm}}
%	
%	\only<3->{\inputminted[firstline=23,lastline=26]{scheme}{code/motivation-lokal.scm}}
%	\begin{itemize}
%		\item<4-> Ausdruck wertet weiterhin korrekt aus, da scheinbar \enquote{die richtigen \texttt{y}} substituiert werden:
%		
%		\mintinline{scheme}{(f 3 2)}\\[0.2cm]
%		$\rightarrow$ \mintinline{scheme}{(let ((y (+ 1 3)) (b (- 1 2))) (+ (square y) (square b) (* y b 3)))}
%		\item<4-> Das Substitutionsmodell liefert keine Erklärung für dieses Verhalten.
%	\end{itemize}
%\end{frame}

\begin{frame}[t]{Akkumulatoren}
	\begin{itemize}
		\item Ein \bet{Akkumulator} speichert genau einen Zahlwert.
		Zahlen, die an den Akkumulator übergeben werden, werden zum aktuell gespeicherten Wert addiert.
		Dieses Verhalten soll im Folgenden in Scheme bzw. Racket realisiert werden. \pause
		\item Anforderungen:
		\begin{itemize}
			\item Prozedur, um einen Akkumulator mit einem Initialwert zu erzeugen.
			\item Prozedur, um dem Akkumulator eine Zahl zu übergeben, die zum gespeicherten Wert addiert wird.
			Bei Aufruf soll der neue Wert gespeichert und ausgegeben werden. \pause
		\end{itemize}
		\item[]
		\item \bet{Fragen:}
		\begin{itemize}
			\item Wie können gespeicherte Werte manipuliert werden?
			\item Erst manipulieren, dann ausgeben: Wie können mehrere Anweisungen hintereinander ausgeführt werden?
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}[t,fragile]{\textit{Special forms} \texttt{begin} und \texttt{set!}}
	\begin{center}
		\texttt{(begin \slot{exp_1} \slot{exp_2} \dots \ \slot{exp_k})}
	\end{center}
	\begin{itemize}
		\item Die Ausdrücke \slot{exp_1} bis \slot{exp_k} werden der Reihe nach ausgewertet.
			Das Ergebnis von \texttt{(begin~\dots)} ist die Rückgabe von \slot{exp_k}. \pause
	\end{itemize}
		\begin{center}
			\texttt{(set! \slot{Name} \slot{exp})}
		\end{center}
	\begin{itemize}
		\item Wertet \slot{exp} aus und speichert das Ergebnis unter dem bereits definierten Namen \slot{Name}. \pause
		\item Rückgabewert: \enquote{The result of the \mintinline{scheme}{set!} expression is unspecified.} \ccite{r5rs}{Kap. 4.1.6}
	\end{itemize}
\end{frame}

\begin{frame}[t,fragile]{}
	\inputminted[fontsize=\normalsize]{scheme}{code/begin-set.scm}
\end{frame}

\begin{frame}[t,fragile]{}
	\begin{itemize}
		\minoritem \minor{Prozedur, um einen Akkumulator mit einem Initialwert zu erzeugen.}
		\minoritem \minor{Prozedur, um dem Akkumulator eine Zahl zu übergeben, die zum gespeicherten Wert addiert wird.
		Bei Aufruf soll der neue Wert gespeichert und ausgegeben werden.} \pause
	\end{itemize}
	
	\bet{Erster Ansatz:}
	\only<2|handout:0>{\inputminted[lastline=6]{scheme}{code/accu-ansatz.scm}}
	\onslide<3->{\inputminted{scheme}{code/accu-ansatz.scm}}
	
	\begin{itemize}
		\item<4-> Manipulation von \texttt{accu} wird offensichtlich nicht gespeichert.
		\item<5-> Erinnerung (Folie~\ref{folie:subst-bem}): \enquote{Arguments to Scheme procedures are always passed by value}
		\item<6-> Außerdem problematisch: Direkter Zugriff auf \texttt{my-accu} möglich.
	\end{itemize}
\end{frame}

\begin{frame}[t,fragile]{}
	\bet{Zweiter Vorschlag:}
	\begin{itemize}
		\item Aktueller Wert des Akkumulators in lokaler Variable speichern und Prozedur zurückgeben, die diese ändert:
		
		\only<1|handout:0>{\inputminted[firstline=1,lastline=3]{scheme}{code/accu-final.scm}}
		
		\only<2->{\inputminted[firstline=5,lastline=10]{scheme}{code/accu-final.scm}}
		
		\item<3-> Beobachtungen:
		\begin{itemize}
			\item<3-> Parameter einer Prozedur (hier: \mintinline{scheme}{init}) sind bereits lokale Variablen
			\item<3-> R\textsuperscript{5}RS-Standard: Rumpf eines \mintinline{scheme}{lambda}-Ausdrucks darf aus mehreren Anweisungen bestehen\footnote<3->{Gilt nicht für die \textit{Racket Teaching Languages}.}.
			\item<3->[$\Rightarrow$] \mintinline{scheme}{let} und \mintinline{scheme}{begin} unnötig
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}[t,fragile]{}
	\bet{Ergebnis:}
	\only<1|handout:0>{\inputminted[firstline=12,lastline=15]{scheme}{code/accu-final.scm}}
	\only<2|handout:0>{\inputminted[firstline=12,lastline=23]{scheme}{code/accu-final.scm}}
	\only<3->{\inputminted[firstline=12,lastline=26]{scheme}{code/accu-final.scm}}
	
	\begin{itemize}
		\item<4-> Warum leistet der Code das Gewünschte?
	\end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Ein Analyseversuch}
	\inputminted[firstline=29,lastline=35]{scheme}{code/accu-final.scm}
	
	Auswertung mithilfe des Substitutionsmodells:
	
	\mintinline{scheme}{((new-accu 100) 10)} \\[0.15cm]
	\onslide<2->{$\rightarrow$ \mintinline{scheme}{((lambda (x) (set! init (+ 100 x)) 100) 10)} \\[0.15cm]}
	\onslide<3->{$\rightarrow$ \mintinline{scheme}{(set! init (+ 100 10)) 100} \\[0.15cm]}
	\onslide<4->{$\rightarrow$ \mintinline{scheme}{100}}
\end{frame}

\begin{frame}[t,fragile]{}
	\bet{Wo liegt das Problem?}
	\inputminted[firstline=20,lastline=23]{scheme}{code/accu-final.scm}
	\begin{itemize}
		\item<2-> Erinnerung (Folie~\ref{folie:funktional}): Ausführung eines Programms entspricht Auswertung einer Funktion.
		\begin{itemize}
			\item Dies entspricht offensichtlich nicht dem Verhalten von \texttt{my-accu}, da die zweite Ausführung mit gleichem Parameter ein unterschiedliches Ergebnis liefert.
		\end{itemize}
		\item<3-> Keine Zustandslosigkeit: Wert einer Variablen ändert sich während der Auswertung.
		\begin{itemize}
			\item Eine Variable ist kein Bezeichner für einen Wert, sondern vielmehr ein Speicherplatz für ein manipulierbares Datum.
			\item Reihenfolge der Auswertungen kann einen erheblichen Einfluss auf das Resultat haben.
			\item Verletzung der referenziellen Transparenz.
		\end{itemize}
		\item<4->[$\Rightarrow$] Paradigmenwechsel durch Verwendung von Wertzuweisungen: \bet{Imperative} statt funktionaler Programmierung.
	\end{itemize}
\end{frame}

\begin{frame}[t,fragile]{}
	\inputminted[firstline=12,lastline=15]{scheme}{code/accu-final.scm}
	\begin{itemize}
		\minoritem \minor{Keine Zustandslosigkeit: Wert einer Variablen ändert sich während der Auswertung.}
		\begin{itemize}
			\minoritem \minor{Eine Variable ist kein Bezeichner für einen Wert, sondern vielmehr ein Speicherplatz für ein manipulierbares Datum.}
			\minoritem \minor{Reihenfolge der Auswertungen kann einen erheblichen Einfluss auf das Resultat haben.}
			\minoritem \minor{Verletzung der referenziellen Transparenz.}
		\end{itemize}
	\end{itemize}
	
	\bet{Fazit:} Das Substitutionsmodell genügt nicht, um die Auswertung von Programmen nachzuvollziehen, die nicht rein funktional konzipiert sind.
\end{frame}